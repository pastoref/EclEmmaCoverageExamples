This project contains test cases that show the relation between EclEmma branch coverage
criterion and well known coverage criteria like "basic condition coverage",
"MCDC", "compound condition coverage".

EclEmma branch coverage criterion has a finer granularity than the traditional branch coverage criterion 
(which coincide with decision coverage). 


EclEmma implements branch coverage at the bytecode level. 
As a consequence 100% branch coverage implies that all the branches at the bytecode level have been evaluated to true and false.
Usually the Java compiler translates "compound conditions" into a tree of basic conditions. Basic conditions are connected by branches.

In practice the condition 

	if ( a == -1 && b == -1 && c == -1 ){
		return true;		//BLOCK-FOR-TRUE-CASE
	} else {
		return false;		//BLOCK-FOR-FALSE-CASE
	}

at the bytecode level, will be equivalent to the following


	if (a == -1 ){
		if ( b == -1 ){
			if ( c == -1 ){
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	} else {
		return false;
	}


More precisely this is the bytecode generated by JDK 8

0: iload_1
       1: iconst_m1
       2: if_icmpne     17	//JUMP TO 17
       5: iload_2
       6: iconst_m1
       7: if_icmpne     17
      10: iload_3
      11: iconst_m1
      12: if_icmpne     17
      15: iconst_1		//BLOCK-FOR-TRUE-CASE
      16: ireturn
      17: iconst_0		//BLOCK-FOR-FALSE-CASE
      18: ireturn


Since EclEmma counts branches at the bytecode level, EclEmma detects 6 branches and not just 2. 

The consequence of this is that, in the presence of a compiler that translates compound conditions as a tree composed by branches that connect basic conditions, the branch coverage criterion implemented in EclEmma subsumes basic condition and decision coverage.
Under this assumption 100%  branch coverage returned by  EclEmma implies that all the basic conditions are "evaluated true" at least once and "evaluated false" at least once.
For the same reason 100%  branch coverage at the bytecode level also implies 100% decision coverage.
Each basic condition in the tree built by the compiler lead to two branches.
By construction, among these small conditions at least one jumps to the BLOCK-FOR-THE-TRUE-CASE of the compound condition, 
and at least one jumps to the BLOCK-FOR-THE-FALSE-CASE of the compound condition.
With 100% bytecode branches also the branch that jump to the BLOCK-FOR-THE-FALSE-CASE and the branch that jumps to BLOCK-FOR-THE-TRUE-CASE are reached.
This implies that we covered decisions.

However, in the case the compiler does not translate a compound condition this way (e.g. because of optimization) this assumption does not hold. 


 
For questions:
 pastore@disco.unimib.it
