This project contains test cases that show the relation between EclEmma branch coverage
criterion and well known coverage criteria like "basic condition coverage",
"MCDC", "compound condition coverage".

EclEmma branch coverage criterion has a finer granularity than the traditional branch coverage criterion 
(which coincide with decision coverage). 


EclEmma implements branch coverage at the bytecode level. 
As a consequence 100% branch coverage implies that all the conditions have been evaluated to true and false.
In Java "compound conditions" are translated into code where the basic conditions are connected by jumps, i.e. branches.

In practice the condition 

	if ( a == -1 && b == -1 && c == -1 ){
		return true;		//BLOCK-FOR-TRUE-CASE
	} else {
		return false;		//BLOCK-FOR-FALSE-CASE
	}

at the bytecode level, will be equivalent to the following


	if (a == -1 ){
		if ( b == -1 ){
			if ( c == -1 ){
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	} else {
		return false;
	}


More precisely this is the generated bytecode

0: iload_1
       1: iconst_m1
       2: if_icmpne     17	//JUMP TO 17
       5: iload_2
       6: iconst_m1
       7: if_icmpne     17
      10: iload_3
      11: iconst_m1
      12: if_icmpne     17
      15: iconst_1		//BLOCK-FOR-TRUE-CASE
      16: ireturn
      17: iconst_0		//BLOCK-FOR-FALSE-CASE
      18: ireturn


This is why EclEmmas detects 6 branches and not just 2. 

The consequence of this is that the branch coverage criterion implemented in EclEmma subsume the basic condition
 coverage criterion (at least as defined in Pezze' & Young - Software Testing and Analysis book).

The original "basic condition coverage criterion" does not care about the real evaluation of 
conditions, in practice it does not take into account the presence of short circuit evaluation.
 
100%  branch coverage returned by  EclEmma implies that all the basic conditions are 
"evaluated true" at least once and "evaluated false" at least once.

100%  branch coverage at the bytecode level also implies 100% decision coverage.
At the bytecode level compound conditions are splitted into small conditions (each with two outgoing bytecode branches). 
By construction, among these small conditions at least one jumps to the BLOCK-FOR-THE-TRUE-CASE of the compound condition, 
and at least one jumps to the BLOCK-FOR-THE-FALSE-CASE of the compound condition.
If Eclemma says that 100% bytecode branches are covered means that both the BLOCK-FOR-THE-TRUE-CASE
and the BLOCK-FOR-THE-FALSE-CASE are reached. So we have covered decisions. 
 

 
 For questions:
 pastore@disco.unimib.it